// Code generated by github.com/ecordell/optgen. DO NOT EDIT.
package config

import (
	defaults "github.com/creasty/defaults"
	helpers "github.com/ecordell/optgen/helpers"
	"time"
)

type AppOption func(a *App)

// NewAppWithOptions creates a new App with the passed in options set
func NewAppWithOptions(opts ...AppOption) *App {
	a := &App{}
	for _, o := range opts {
		o(a)
	}
	return a
}

// NewAppWithOptionsAndDefaults creates a new App with the passed in options set starting from the defaults
func NewAppWithOptionsAndDefaults(opts ...AppOption) *App {
	a := &App{}
	defaults.MustSet(a)
	for _, o := range opts {
		o(a)
	}
	return a
}

// ToOption returns a new AppOption that sets the values from the passed in App
func (a *App) ToOption() AppOption {
	return func(to *App) {
		to.Name = a.Name
		to.Version = a.Version
		to.RunMode = a.RunMode
	}
}

// DebugMap returns a map form of App for debugging
func (a App) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["Name"] = helpers.DebugValue(a.Name, false)
	debugMap["Version"] = helpers.DebugValue(a.Version, false)
	debugMap["RunMode"] = helpers.DebugValue(a.RunMode, false)
	return debugMap
}

// AppWithOptions configures an existing App with the passed in options set
func AppWithOptions(a *App, opts ...AppOption) *App {
	for _, o := range opts {
		o(a)
	}
	return a
}

// WithOptions configures the receiver App with the passed in options set
func (a *App) WithOptions(opts ...AppOption) *App {
	for _, o := range opts {
		o(a)
	}
	return a
}

// WithName returns an option that can set Name on a App
func WithName(name string) AppOption {
	return func(a *App) {
		a.Name = name
	}
}

// WithVersion returns an option that can set Version on a App
func WithVersion(version string) AppOption {
	return func(a *App) {
		a.Version = version
	}
}

// WithRunMode returns an option that can set RunMode on a App
func WithRunMode(runMode string) AppOption {
	return func(a *App) {
		a.RunMode = runMode
	}
}

type LogOption func(l *Log)

// NewLogWithOptions creates a new Log with the passed in options set
func NewLogWithOptions(opts ...LogOption) *Log {
	l := &Log{}
	for _, o := range opts {
		o(l)
	}
	return l
}

// NewLogWithOptionsAndDefaults creates a new Log with the passed in options set starting from the defaults
func NewLogWithOptionsAndDefaults(opts ...LogOption) *Log {
	l := &Log{}
	defaults.MustSet(l)
	for _, o := range opts {
		o(l)
	}
	return l
}

// ToOption returns a new LogOption that sets the values from the passed in Log
func (l *Log) ToOption() LogOption {
	return func(to *Log) {
		to.Level = l.Level
	}
}

// DebugMap returns a map form of Log for debugging
func (l Log) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["Level"] = helpers.DebugValue(l.Level, false)
	return debugMap
}

// LogWithOptions configures an existing Log with the passed in options set
func LogWithOptions(l *Log, opts ...LogOption) *Log {
	for _, o := range opts {
		o(l)
	}
	return l
}

// WithOptions configures the receiver Log with the passed in options set
func (l *Log) WithOptions(opts ...LogOption) *Log {
	for _, o := range opts {
		o(l)
	}
	return l
}

// WithLevel returns an option that can set Level on a Log
func WithLevel(level string) LogOption {
	return func(l *Log) {
		l.Level = level
	}
}

type FeatureOption func(f *Feature)

// NewFeatureWithOptions creates a new Feature with the passed in options set
func NewFeatureWithOptions(opts ...FeatureOption) *Feature {
	f := &Feature{}
	for _, o := range opts {
		o(f)
	}
	return f
}

// NewFeatureWithOptionsAndDefaults creates a new Feature with the passed in options set starting from the defaults
func NewFeatureWithOptionsAndDefaults(opts ...FeatureOption) *Feature {
	f := &Feature{}
	defaults.MustSet(f)
	for _, o := range opts {
		o(f)
	}
	return f
}

// ToOption returns a new FeatureOption that sets the values from the passed in Feature
func (f *Feature) ToOption() FeatureOption {
	return func(to *Feature) {
		to.ShutdownGracePeriod = f.ShutdownGracePeriod
	}
}

// DebugMap returns a map form of Feature for debugging
func (f Feature) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["ShutdownGracePeriod"] = helpers.DebugValue(f.ShutdownGracePeriod, false)
	return debugMap
}

// FeatureWithOptions configures an existing Feature with the passed in options set
func FeatureWithOptions(f *Feature, opts ...FeatureOption) *Feature {
	for _, o := range opts {
		o(f)
	}
	return f
}

// WithOptions configures the receiver Feature with the passed in options set
func (f *Feature) WithOptions(opts ...FeatureOption) *Feature {
	for _, o := range opts {
		o(f)
	}
	return f
}

// WithShutdownGracePeriod returns an option that can set ShutdownGracePeriod on a Feature
func WithShutdownGracePeriod(shutdownGracePeriod time.Duration) FeatureOption {
	return func(f *Feature) {
		f.ShutdownGracePeriod = shutdownGracePeriod
	}
}

type DataStoreOption func(d *DataStore)

// NewDataStoreWithOptions creates a new DataStore with the passed in options set
func NewDataStoreWithOptions(opts ...DataStoreOption) *DataStore {
	d := &DataStore{}
	for _, o := range opts {
		o(d)
	}
	return d
}

// NewDataStoreWithOptionsAndDefaults creates a new DataStore with the passed in options set starting from the defaults
func NewDataStoreWithOptionsAndDefaults(opts ...DataStoreOption) *DataStore {
	d := &DataStore{}
	defaults.MustSet(d)
	for _, o := range opts {
		o(d)
	}
	return d
}

// ToOption returns a new DataStoreOption that sets the values from the passed in DataStore
func (d *DataStore) ToOption() DataStoreOption {
	return func(to *DataStore) {
		to.Engine = d.Engine
		to.GcWindows = d.GcWindows
		to.GcMaxOperationTime = d.GcMaxOperationTime
		to.MigrationPhase = d.MigrationPhase
	}
}

// DebugMap returns a map form of DataStore for debugging
func (d DataStore) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["Engine"] = helpers.DebugValue(d.Engine, false)
	debugMap["GcWindows"] = helpers.DebugValue(d.GcWindows, false)
	debugMap["GcMaxOperationTime"] = helpers.DebugValue(d.GcMaxOperationTime, false)
	debugMap["MigrationPhase"] = helpers.DebugValue(d.MigrationPhase, false)
	return debugMap
}

// DataStoreWithOptions configures an existing DataStore with the passed in options set
func DataStoreWithOptions(d *DataStore, opts ...DataStoreOption) *DataStore {
	for _, o := range opts {
		o(d)
	}
	return d
}

// WithOptions configures the receiver DataStore with the passed in options set
func (d *DataStore) WithOptions(opts ...DataStoreOption) *DataStore {
	for _, o := range opts {
		o(d)
	}
	return d
}

// WithEngine returns an option that can set Engine on a DataStore
func WithEngine(engine string) DataStoreOption {
	return func(d *DataStore) {
		d.Engine = engine
	}
}

// WithGcWindows returns an option that can set GcWindows on a DataStore
func WithGcWindows(gcWindows time.Duration) DataStoreOption {
	return func(d *DataStore) {
		d.GcWindows = gcWindows
	}
}

// WithGcMaxOperationTime returns an option that can set GcMaxOperationTime on a DataStore
func WithGcMaxOperationTime(gcMaxOperationTime time.Duration) DataStoreOption {
	return func(d *DataStore) {
		d.GcMaxOperationTime = gcMaxOperationTime
	}
}

// WithMigrationPhase returns an option that can set MigrationPhase on a DataStore
func WithMigrationPhase(migrationPhase string) DataStoreOption {
	return func(d *DataStore) {
		d.MigrationPhase = migrationPhase
	}
}

type MysqlOption func(m *Mysql)

// NewMysqlWithOptions creates a new Mysql with the passed in options set
func NewMysqlWithOptions(opts ...MysqlOption) *Mysql {
	m := &Mysql{}
	for _, o := range opts {
		o(m)
	}
	return m
}

// NewMysqlWithOptionsAndDefaults creates a new Mysql with the passed in options set starting from the defaults
func NewMysqlWithOptionsAndDefaults(opts ...MysqlOption) *Mysql {
	m := &Mysql{}
	defaults.MustSet(m)
	for _, o := range opts {
		o(m)
	}
	return m
}

// ToOption returns a new MysqlOption that sets the values from the passed in Mysql
func (m *Mysql) ToOption() MysqlOption {
	return func(to *Mysql) {
		to.Host = m.Host
		to.Port = m.Port
		to.Username = m.Username
		to.Password = m.Password
		to.DBName = m.DBName
		to.MaxIdleConnections = m.MaxIdleConnections
		to.MaxOpenConnections = m.MaxOpenConnections
		to.MaxConnectionLifeTime = m.MaxConnectionLifeTime
	}
}

// DebugMap returns a map form of Mysql for debugging
func (m Mysql) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["Host"] = helpers.DebugValue(m.Host, false)
	debugMap["Port"] = helpers.DebugValue(m.Port, false)
	debugMap["Username"] = helpers.DebugValue(m.Username, false)
	debugMap["Password"] = helpers.SensitiveDebugValue(m.Password)
	debugMap["DBName"] = helpers.DebugValue(m.DBName, false)
	debugMap["MaxIdleConnections"] = helpers.DebugValue(m.MaxIdleConnections, false)
	debugMap["MaxOpenConnections"] = helpers.DebugValue(m.MaxOpenConnections, false)
	debugMap["MaxConnectionLifeTime"] = helpers.DebugValue(m.MaxConnectionLifeTime, false)
	return debugMap
}

// MysqlWithOptions configures an existing Mysql with the passed in options set
func MysqlWithOptions(m *Mysql, opts ...MysqlOption) *Mysql {
	for _, o := range opts {
		o(m)
	}
	return m
}

// WithOptions configures the receiver Mysql with the passed in options set
func (m *Mysql) WithOptions(opts ...MysqlOption) *Mysql {
	for _, o := range opts {
		o(m)
	}
	return m
}

// WithHost returns an option that can set Host on a Mysql
func WithHost(host string) MysqlOption {
	return func(m *Mysql) {
		m.Host = host
	}
}

// WithPort returns an option that can set Port on a Mysql
func WithPort(port int) MysqlOption {
	return func(m *Mysql) {
		m.Port = port
	}
}

// WithUsername returns an option that can set Username on a Mysql
func WithUsername(username string) MysqlOption {
	return func(m *Mysql) {
		m.Username = username
	}
}

// WithPassword returns an option that can set Password on a Mysql
func WithPassword(password string) MysqlOption {
	return func(m *Mysql) {
		m.Password = password
	}
}

// WithDBName returns an option that can set DBName on a Mysql
func WithDBName(dBName string) MysqlOption {
	return func(m *Mysql) {
		m.DBName = dBName
	}
}

// WithMaxIdleConnections returns an option that can set MaxIdleConnections on a Mysql
func WithMaxIdleConnections(maxIdleConnections int) MysqlOption {
	return func(m *Mysql) {
		m.MaxIdleConnections = maxIdleConnections
	}
}

// WithMaxOpenConnections returns an option that can set MaxOpenConnections on a Mysql
func WithMaxOpenConnections(maxOpenConnections int) MysqlOption {
	return func(m *Mysql) {
		m.MaxOpenConnections = maxOpenConnections
	}
}

// WithMaxConnectionLifeTime returns an option that can set MaxConnectionLifeTime on a Mysql
func WithMaxConnectionLifeTime(maxConnectionLifeTime time.Duration) MysqlOption {
	return func(m *Mysql) {
		m.MaxConnectionLifeTime = maxConnectionLifeTime
	}
}

type PostgresOption func(p *Postgres)

// NewPostgresWithOptions creates a new Postgres with the passed in options set
func NewPostgresWithOptions(opts ...PostgresOption) *Postgres {
	p := &Postgres{}
	for _, o := range opts {
		o(p)
	}
	return p
}

// NewPostgresWithOptionsAndDefaults creates a new Postgres with the passed in options set starting from the defaults
func NewPostgresWithOptionsAndDefaults(opts ...PostgresOption) *Postgres {
	p := &Postgres{}
	defaults.MustSet(p)
	for _, o := range opts {
		o(p)
	}
	return p
}

// ToOption returns a new PostgresOption that sets the values from the passed in Postgres
func (p *Postgres) ToOption() PostgresOption {
	return func(to *Postgres) {
		to.PHost = p.PHost
		to.PPort = p.PPort
		to.DBNAME = p.DBNAME
		to.DBUser = p.DBUser
		to.DBPassword = p.DBPassword
		to.PMaxIdleConnections = p.PMaxIdleConnections
		to.PMaxOpenConnections = p.PMaxOpenConnections
		to.PMaxConnectionLifeTime = p.PMaxConnectionLifeTime
	}
}

// DebugMap returns a map form of Postgres for debugging
func (p Postgres) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["PHost"] = helpers.DebugValue(p.PHost, false)
	debugMap["PPort"] = helpers.DebugValue(p.PPort, false)
	debugMap["DBNAME"] = helpers.DebugValue(p.DBNAME, false)
	debugMap["DBUser"] = helpers.DebugValue(p.DBUser, false)
	debugMap["DBPassword"] = helpers.DebugValue(p.DBPassword, false)
	debugMap["PMaxIdleConnections"] = helpers.DebugValue(p.PMaxIdleConnections, false)
	debugMap["PMaxOpenConnections"] = helpers.DebugValue(p.PMaxOpenConnections, false)
	debugMap["PMaxConnectionLifeTime"] = helpers.DebugValue(p.PMaxConnectionLifeTime, false)
	return debugMap
}

// PostgresWithOptions configures an existing Postgres with the passed in options set
func PostgresWithOptions(p *Postgres, opts ...PostgresOption) *Postgres {
	for _, o := range opts {
		o(p)
	}
	return p
}

// WithOptions configures the receiver Postgres with the passed in options set
func (p *Postgres) WithOptions(opts ...PostgresOption) *Postgres {
	for _, o := range opts {
		o(p)
	}
	return p
}

// WithPHost returns an option that can set PHost on a Postgres
func WithPHost(pHost string) PostgresOption {
	return func(p *Postgres) {
		p.PHost = pHost
	}
}

// WithPPort returns an option that can set PPort on a Postgres
func WithPPort(pPort int) PostgresOption {
	return func(p *Postgres) {
		p.PPort = pPort
	}
}

// WithDBNAME returns an option that can set DBNAME on a Postgres
func WithDBNAME(dBNAME string) PostgresOption {
	return func(p *Postgres) {
		p.DBNAME = dBNAME
	}
}

// WithDBUser returns an option that can set DBUser on a Postgres
func WithDBUser(dBUser string) PostgresOption {
	return func(p *Postgres) {
		p.DBUser = dBUser
	}
}

// WithDBPassword returns an option that can set DBPassword on a Postgres
func WithDBPassword(dBPassword string) PostgresOption {
	return func(p *Postgres) {
		p.DBPassword = dBPassword
	}
}

// WithPMaxIdleConnections returns an option that can set PMaxIdleConnections on a Postgres
func WithPMaxIdleConnections(pMaxIdleConnections int) PostgresOption {
	return func(p *Postgres) {
		p.PMaxIdleConnections = pMaxIdleConnections
	}
}

// WithPMaxOpenConnections returns an option that can set PMaxOpenConnections on a Postgres
func WithPMaxOpenConnections(pMaxOpenConnections int) PostgresOption {
	return func(p *Postgres) {
		p.PMaxOpenConnections = pMaxOpenConnections
	}
}

// WithPMaxConnectionLifeTime returns an option that can set PMaxConnectionLifeTime on a Postgres
func WithPMaxConnectionLifeTime(pMaxConnectionLifeTime time.Duration) PostgresOption {
	return func(p *Postgres) {
		p.PMaxConnectionLifeTime = pMaxConnectionLifeTime
	}
}

type UploadOption func(u *Upload)

// NewUploadWithOptions creates a new Upload with the passed in options set
func NewUploadWithOptions(opts ...UploadOption) *Upload {
	u := &Upload{}
	for _, o := range opts {
		o(u)
	}
	return u
}

// NewUploadWithOptionsAndDefaults creates a new Upload with the passed in options set starting from the defaults
func NewUploadWithOptionsAndDefaults(opts ...UploadOption) *Upload {
	u := &Upload{}
	defaults.MustSet(u)
	for _, o := range opts {
		o(u)
	}
	return u
}

// ToOption returns a new UploadOption that sets the values from the passed in Upload
func (u *Upload) ToOption() UploadOption {
	return func(to *Upload) {
		to.Enable = u.Enable
		to.Storage = u.Storage
		to.WorkersNum = u.WorkersNum
		to.RecordsBufferSize = u.RecordsBufferSize
		to.FlushInterval = u.FlushInterval
		to.EnableDetailedRecording = u.EnableDetailedRecording
	}
}

// DebugMap returns a map form of Upload for debugging
func (u Upload) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["Enable"] = helpers.DebugValue(u.Enable, false)
	debugMap["Storage"] = helpers.DebugValue(u.Storage, false)
	debugMap["WorkersNum"] = helpers.DebugValue(u.WorkersNum, false)
	debugMap["RecordsBufferSize"] = helpers.DebugValue(u.RecordsBufferSize, false)
	debugMap["FlushInterval"] = helpers.DebugValue(u.FlushInterval, false)
	debugMap["EnableDetailedRecording"] = helpers.DebugValue(u.EnableDetailedRecording, false)
	return debugMap
}

// UploadWithOptions configures an existing Upload with the passed in options set
func UploadWithOptions(u *Upload, opts ...UploadOption) *Upload {
	for _, o := range opts {
		o(u)
	}
	return u
}

// WithOptions configures the receiver Upload with the passed in options set
func (u *Upload) WithOptions(opts ...UploadOption) *Upload {
	for _, o := range opts {
		o(u)
	}
	return u
}

// WithEnable returns an option that can set Enable on a Upload
func WithEnable(enable bool) UploadOption {
	return func(u *Upload) {
		u.Enable = enable
	}
}

// WithStorage returns an option that can set Storage on a Upload
func WithStorage(storage string) UploadOption {
	return func(u *Upload) {
		u.Storage = storage
	}
}

// WithWorkersNum returns an option that can set WorkersNum on a Upload
func WithWorkersNum(workersNum int) UploadOption {
	return func(u *Upload) {
		u.WorkersNum = workersNum
	}
}

// WithRecordsBufferSize returns an option that can set RecordsBufferSize on a Upload
func WithRecordsBufferSize(recordsBufferSize uint64) UploadOption {
	return func(u *Upload) {
		u.RecordsBufferSize = recordsBufferSize
	}
}

// WithFlushInterval returns an option that can set FlushInterval on a Upload
func WithFlushInterval(flushInterval time.Duration) UploadOption {
	return func(u *Upload) {
		u.FlushInterval = flushInterval
	}
}

// WithEnableDetailedRecording returns an option that can set EnableDetailedRecording on a Upload
func WithEnableDetailedRecording(enableDetailedRecording bool) UploadOption {
	return func(u *Upload) {
		u.EnableDetailedRecording = enableDetailedRecording
	}
}

type DownloadOption func(d *Download)

// NewDownloadWithOptions creates a new Download with the passed in options set
func NewDownloadWithOptions(opts ...DownloadOption) *Download {
	d := &Download{}
	for _, o := range opts {
		o(d)
	}
	return d
}

// NewDownloadWithOptionsAndDefaults creates a new Download with the passed in options set starting from the defaults
func NewDownloadWithOptionsAndDefaults(opts ...DownloadOption) *Download {
	d := &Download{}
	defaults.MustSet(d)
	for _, o := range opts {
		o(d)
	}
	return d
}

// ToOption returns a new DownloadOption that sets the values from the passed in Download
func (d *Download) ToOption() DownloadOption {
	return func(to *Download) {
		to.PurgeDelay = d.PurgeDelay
		to.Backends = d.Backends
	}
}

// DebugMap returns a map form of Download for debugging
func (d Download) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["PurgeDelay"] = helpers.DebugValue(d.PurgeDelay, false)
	debugMap["Backends"] = helpers.DebugValue(d.Backends, false)
	return debugMap
}

// DownloadWithOptions configures an existing Download with the passed in options set
func DownloadWithOptions(d *Download, opts ...DownloadOption) *Download {
	for _, o := range opts {
		o(d)
	}
	return d
}

// WithOptions configures the receiver Download with the passed in options set
func (d *Download) WithOptions(opts ...DownloadOption) *Download {
	for _, o := range opts {
		o(d)
	}
	return d
}

// WithPurgeDelay returns an option that can set PurgeDelay on a Download
func WithPurgeDelay(purgeDelay time.Duration) DownloadOption {
	return func(d *Download) {
		d.PurgeDelay = purgeDelay
	}
}

// WithBackends returns an option that can append Backendss to Download.Backends
func WithBackends(backends string) DownloadOption {
	return func(d *Download) {
		d.Backends = append(d.Backends, backends)
	}
}

// SetBackends returns an option that can set Backends on a Download
func SetBackends(backends []string) DownloadOption {
	return func(d *Download) {
		d.Backends = backends
	}
}

type BackendsOption func(b *Backends)

// NewBackendsWithOptions creates a new Backends with the passed in options set
func NewBackendsWithOptions(opts ...BackendsOption) *Backends {
	b := &Backends{}
	for _, o := range opts {
		o(b)
	}
	return b
}

// NewBackendsWithOptionsAndDefaults creates a new Backends with the passed in options set starting from the defaults
func NewBackendsWithOptionsAndDefaults(opts ...BackendsOption) *Backends {
	b := &Backends{}
	defaults.MustSet(b)
	for _, o := range opts {
		o(b)
	}
	return b
}

// ToOption returns a new BackendsOption that sets the values from the passed in Backends
func (b *Backends) ToOption() BackendsOption {
	return func(to *Backends) {
		to.CSV = b.CSV
	}
}

// DebugMap returns a map form of Backends for debugging
func (b Backends) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["CSV"] = helpers.DebugValue(b.CSV, false)
	return debugMap
}

// BackendsWithOptions configures an existing Backends with the passed in options set
func BackendsWithOptions(b *Backends, opts ...BackendsOption) *Backends {
	for _, o := range opts {
		o(b)
	}
	return b
}

// WithOptions configures the receiver Backends with the passed in options set
func (b *Backends) WithOptions(opts ...BackendsOption) *Backends {
	for _, o := range opts {
		o(b)
	}
	return b
}

// WithCSV returns an option that can set CSV on a Backends
func WithCSV(cSV CSVOpt) BackendsOption {
	return func(b *Backends) {
		b.CSV = cSV
	}
}

type CSVOptOption func(c *CSVOpt)

// NewCSVOptWithOptions creates a new CSVOpt with the passed in options set
func NewCSVOptWithOptions(opts ...CSVOptOption) *CSVOpt {
	c := &CSVOpt{}
	for _, o := range opts {
		o(c)
	}
	return c
}

// NewCSVOptWithOptionsAndDefaults creates a new CSVOpt with the passed in options set starting from the defaults
func NewCSVOptWithOptionsAndDefaults(opts ...CSVOptOption) *CSVOpt {
	c := &CSVOpt{}
	defaults.MustSet(c)
	for _, o := range opts {
		o(c)
	}
	return c
}

// ToOption returns a new CSVOptOption that sets the values from the passed in CSVOpt
func (c *CSVOpt) ToOption() CSVOptOption {
	return func(to *CSVOpt) {
		to.CSVDIR = c.CSVDIR
	}
}

// DebugMap returns a map form of CSVOpt for debugging
func (c CSVOpt) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["CSVDIR"] = helpers.DebugValue(c.CSVDIR, false)
	return debugMap
}

// CSVOptWithOptions configures an existing CSVOpt with the passed in options set
func CSVOptWithOptions(c *CSVOpt, opts ...CSVOptOption) *CSVOpt {
	for _, o := range opts {
		o(c)
	}
	return c
}

// WithOptions configures the receiver CSVOpt with the passed in options set
func (c *CSVOpt) WithOptions(opts ...CSVOptOption) *CSVOpt {
	for _, o := range opts {
		o(c)
	}
	return c
}

// WithCSVDIR returns an option that can set CSVDIR on a CSVOpt
func WithCSVDIR(cSVDIR string) CSVOptOption {
	return func(c *CSVOpt) {
		c.CSVDIR = cSVDIR
	}
}

type EnvConfigOption func(e *EnvConfig)

// NewEnvConfigWithOptions creates a new EnvConfig with the passed in options set
func NewEnvConfigWithOptions(opts ...EnvConfigOption) *EnvConfig {
	e := &EnvConfig{}
	for _, o := range opts {
		o(e)
	}
	return e
}

// NewEnvConfigWithOptionsAndDefaults creates a new EnvConfig with the passed in options set starting from the defaults
func NewEnvConfigWithOptionsAndDefaults(opts ...EnvConfigOption) *EnvConfig {
	e := &EnvConfig{}
	defaults.MustSet(e)
	for _, o := range opts {
		o(e)
	}
	return e
}

// ToOption returns a new EnvConfigOption that sets the values from the passed in EnvConfig
func (e *EnvConfig) ToOption() EnvConfigOption {
	return func(to *EnvConfig) {
		to.TaskID = e.TaskID
		to.LogDir = e.LogDir
	}
}

// DebugMap returns a map form of EnvConfig for debugging
func (e EnvConfig) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["TaskID"] = helpers.DebugValue(e.TaskID, false)
	debugMap["LogDir"] = helpers.DebugValue(e.LogDir, false)
	return debugMap
}

// EnvConfigWithOptions configures an existing EnvConfig with the passed in options set
func EnvConfigWithOptions(e *EnvConfig, opts ...EnvConfigOption) *EnvConfig {
	for _, o := range opts {
		o(e)
	}
	return e
}

// WithOptions configures the receiver EnvConfig with the passed in options set
func (e *EnvConfig) WithOptions(opts ...EnvConfigOption) *EnvConfig {
	for _, o := range opts {
		o(e)
	}
	return e
}

// WithTaskID returns an option that can set TaskID on a EnvConfig
func WithTaskID(taskID string) EnvConfigOption {
	return func(e *EnvConfig) {
		e.TaskID = taskID
	}
}

// WithLogDir returns an option that can set LogDir on a EnvConfig
func WithLogDir(logDir string) EnvConfigOption {
	return func(e *EnvConfig) {
		e.LogDir = logDir
	}
}
