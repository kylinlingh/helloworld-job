// Code generated by github.com/ecordell/optgen. DO NOT EDIT.
package config

import (
	defaults "github.com/creasty/defaults"
	helpers "github.com/ecordell/optgen/helpers"
	"time"
)

type ConfigOption func(c *Config)

// NewConfigWithOptions creates a new Config with the passed in options set
func NewConfigWithOptions(opts ...ConfigOption) *Config {
	c := &Config{}
	for _, o := range opts {
		o(c)
	}
	return c
}

// NewConfigWithOptionsAndDefaults creates a new Config with the passed in options set starting from the defaults
func NewConfigWithOptionsAndDefaults(opts ...ConfigOption) *Config {
	c := &Config{}
	defaults.MustSet(c)
	for _, o := range opts {
		o(c)
	}
	return c
}

// ToOption returns a new ConfigOption that sets the values from the passed in Config
func (c *Config) ToOption() ConfigOption {
	return func(to *Config) {}
}

// DebugMap returns a map form of Config for debugging
func (c Config) DebugMap() map[string]any {
	debugMap := map[string]any{}
	return debugMap
}

// ConfigWithOptions configures an existing Config with the passed in options set
func ConfigWithOptions(c *Config, opts ...ConfigOption) *Config {
	for _, o := range opts {
		o(c)
	}
	return c
}

// WithOptions configures the receiver Config with the passed in options set
func (c *Config) WithOptions(opts ...ConfigOption) *Config {
	for _, o := range opts {
		o(c)
	}
	return c
}

type AppOption func(a *App)

// NewAppWithOptions creates a new App with the passed in options set
func NewAppWithOptions(opts ...AppOption) *App {
	a := &App{}
	for _, o := range opts {
		o(a)
	}
	return a
}

// NewAppWithOptionsAndDefaults creates a new App with the passed in options set starting from the defaults
func NewAppWithOptionsAndDefaults(opts ...AppOption) *App {
	a := &App{}
	defaults.MustSet(a)
	for _, o := range opts {
		o(a)
	}
	return a
}

// ToOption returns a new AppOption that sets the values from the passed in App
func (a *App) ToOption() AppOption {
	return func(to *App) {
		to.Name = a.Name
		to.Version = a.Version
		to.RunMode = a.RunMode
	}
}

// DebugMap returns a map form of App for debugging
func (a App) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["Name"] = helpers.DebugValue(a.Name, false)
	debugMap["Version"] = helpers.DebugValue(a.Version, false)
	debugMap["RunMode"] = helpers.DebugValue(a.RunMode, false)
	return debugMap
}

// AppWithOptions configures an existing App with the passed in options set
func AppWithOptions(a *App, opts ...AppOption) *App {
	for _, o := range opts {
		o(a)
	}
	return a
}

// WithOptions configures the receiver App with the passed in options set
func (a *App) WithOptions(opts ...AppOption) *App {
	for _, o := range opts {
		o(a)
	}
	return a
}

// WithName returns an option that can set Name on a App
func WithName(name string) AppOption {
	return func(a *App) {
		a.Name = name
	}
}

// WithVersion returns an option that can set Version on a App
func WithVersion(version string) AppOption {
	return func(a *App) {
		a.Version = version
	}
}

// WithRunMode returns an option that can set RunMode on a App
func WithRunMode(runMode string) AppOption {
	return func(a *App) {
		a.RunMode = runMode
	}
}

type LogOption func(l *Log)

// NewLogWithOptions creates a new Log with the passed in options set
func NewLogWithOptions(opts ...LogOption) *Log {
	l := &Log{}
	for _, o := range opts {
		o(l)
	}
	return l
}

// NewLogWithOptionsAndDefaults creates a new Log with the passed in options set starting from the defaults
func NewLogWithOptionsAndDefaults(opts ...LogOption) *Log {
	l := &Log{}
	defaults.MustSet(l)
	for _, o := range opts {
		o(l)
	}
	return l
}

// ToOption returns a new LogOption that sets the values from the passed in Log
func (l *Log) ToOption() LogOption {
	return func(to *Log) {
		to.Level = l.Level
	}
}

// DebugMap returns a map form of Log for debugging
func (l Log) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["Level"] = helpers.DebugValue(l.Level, false)
	return debugMap
}

// LogWithOptions configures an existing Log with the passed in options set
func LogWithOptions(l *Log, opts ...LogOption) *Log {
	for _, o := range opts {
		o(l)
	}
	return l
}

// WithOptions configures the receiver Log with the passed in options set
func (l *Log) WithOptions(opts ...LogOption) *Log {
	for _, o := range opts {
		o(l)
	}
	return l
}

// WithLevel returns an option that can set Level on a Log
func WithLevel(level string) LogOption {
	return func(l *Log) {
		l.Level = level
	}
}

type FeatureOption func(f *Feature)

// NewFeatureWithOptions creates a new Feature with the passed in options set
func NewFeatureWithOptions(opts ...FeatureOption) *Feature {
	f := &Feature{}
	for _, o := range opts {
		o(f)
	}
	return f
}

// NewFeatureWithOptionsAndDefaults creates a new Feature with the passed in options set starting from the defaults
func NewFeatureWithOptionsAndDefaults(opts ...FeatureOption) *Feature {
	f := &Feature{}
	defaults.MustSet(f)
	for _, o := range opts {
		o(f)
	}
	return f
}

// ToOption returns a new FeatureOption that sets the values from the passed in Feature
func (f *Feature) ToOption() FeatureOption {
	return func(to *Feature) {
		to.ShutdownGracePeriod = f.ShutdownGracePeriod
	}
}

// DebugMap returns a map form of Feature for debugging
func (f Feature) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["ShutdownGracePeriod"] = helpers.DebugValue(f.ShutdownGracePeriod, false)
	return debugMap
}

// FeatureWithOptions configures an existing Feature with the passed in options set
func FeatureWithOptions(f *Feature, opts ...FeatureOption) *Feature {
	for _, o := range opts {
		o(f)
	}
	return f
}

// WithOptions configures the receiver Feature with the passed in options set
func (f *Feature) WithOptions(opts ...FeatureOption) *Feature {
	for _, o := range opts {
		o(f)
	}
	return f
}

// WithShutdownGracePeriod returns an option that can set ShutdownGracePeriod on a Feature
func WithShutdownGracePeriod(shutdownGracePeriod time.Duration) FeatureOption {
	return func(f *Feature) {
		f.ShutdownGracePeriod = shutdownGracePeriod
	}
}

type PGOption func(p *PG)

// NewPGWithOptions creates a new PG with the passed in options set
func NewPGWithOptions(opts ...PGOption) *PG {
	p := &PG{}
	for _, o := range opts {
		o(p)
	}
	return p
}

// NewPGWithOptionsAndDefaults creates a new PG with the passed in options set starting from the defaults
func NewPGWithOptionsAndDefaults(opts ...PGOption) *PG {
	p := &PG{}
	defaults.MustSet(p)
	for _, o := range opts {
		o(p)
	}
	return p
}

// ToOption returns a new PGOption that sets the values from the passed in PG
func (p *PG) ToOption() PGOption {
	return func(to *PG) {
		to.PoolMax = p.PoolMax
		to.URE = p.URE
	}
}

// DebugMap returns a map form of PG for debugging
func (p PG) DebugMap() map[string]any {
	debugMap := map[string]any{}
	debugMap["PoolMax"] = helpers.DebugValue(p.PoolMax, false)
	debugMap["URE"] = helpers.DebugValue(p.URE, false)
	return debugMap
}

// PGWithOptions configures an existing PG with the passed in options set
func PGWithOptions(p *PG, opts ...PGOption) *PG {
	for _, o := range opts {
		o(p)
	}
	return p
}

// WithOptions configures the receiver PG with the passed in options set
func (p *PG) WithOptions(opts ...PGOption) *PG {
	for _, o := range opts {
		o(p)
	}
	return p
}

// WithPoolMax returns an option that can set PoolMax on a PG
func WithPoolMax(poolMax int) PGOption {
	return func(p *PG) {
		p.PoolMax = poolMax
	}
}

// WithURE returns an option that can set URE on a PG
func WithURE(uRE string) PGOption {
	return func(p *PG) {
		p.URE = uRE
	}
}
